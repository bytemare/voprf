# (V)OPRF : (Verifiable) Oblivious Pseudorandom Functions

[![VOPRF](https://github.com/bytemare/voprf/actions/workflows/ci.yml/badge.svg)](https://github.com/bytemare/voprf/actions/workflows/ci.yml)
[![Go Reference](https://pkg.go.dev/badge/github.com/bytemare/voprf.svg)](https://pkg.go.dev/github.com/bytemare/voprf)
[![codecov](https://codecov.io/gh/bytemare/voprf/branch/main/graph/badge.svg?token=5bQfB0OctA)](https://codecov.io/gh/bytemare/voprf)
[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fbytemare%2Fvoprf.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Fbytemare%2Fvoprf?ref=badge_shield)

Package voprf provides abstracted access to Oblivious Pseudorandom Functions (OPRF) using Elliptic Curves (EC-OPRF).

This implementation supports the base and verifiable modes, and can be used with multiplicative and additive blinding.

This work in progress implements https://tools.ietf.org/html/draft-irtf-cfrg-voprf.

## OPRF

OPRF allow a client to generate a random-like output with uncontrolled and unknown input, allowing for added input entropy. 

This OPRF is a two-party protocol which outputs a hash over input from both the client and the server, without any party learning anything about the other's input.
This function can be extended to a VOPRF with the addition of a non-interactive zero-knowledge proof. Here the client verifies correctness of the computation using the server's public key associated to the server's secret key it has committed to use as input.

## Verifiable vs. Non-Verifiable (Base)

In a verifiable setup, the client must be provided with the server's public key beforehand.

## Multiplicative vs. Additive blinding

With multiplicative blinding, the blinding consists in a scalar multiplication of an element representing the input (using hash-to-curve) with a per session random scalar.

Additive blinding is a client-side optimisation. The client pre-processes some values ahead of the protocol execution, and uses them as the blinding factor. A random scalar is chosen once to blind the group's generator, and the server's public key. To blind the input, we simply add the resulting point with the blinded generator. Upon reception of the server's evaluation, we revert the blinding by subtracting the evaluation by the blinded public key. By commutativity of scalar multiplication in the group, we arrive at the same result as the direct multiplicative blinding.
This has the advantage of being faster than variable-based multiplication. Note that this demands that the client is provided with the server's public key and can retain sensitive information (the blinded elements) between sessions.

## Ciphersuites and bit security

| Ciphersuite  	| Identifier  	| Bit security | Implementation |
|---------------|:-------------:|:------------:|:--------------:|
|   RistrettoSha512	|   0x0001	|   128	| github.com/gtank/ristretto255 |
|   ~~Decaf448~~	|   0x0002	|   224	| missing |
|   P256Sha512	|   0x0003	|   128	| github.com/armfazh/h2c-go-ref |
|   P384Sha384	|   0x0004	|   192	| github.com/armfazh/h2c-go-ref |
|   P521Sha512	|   0x0005	|   256	| github.com/armfazh/h2c-go-ref |

## Usage

```go
import "github.com/bytemare/voprf"
```



Between Base and Verifiable mode, or multiplicative and additive blinding, only the setup of the client and server change in usage.
The rest of the execution remains strictly the same. 

### Generate a server key pair

A new keypair is automatically created when calling the server with a nil argument
```go
server := voprf.Ristretto255.Server(nil)
```

A keypair can also be generated by directly calling KeyGen()

```go
server.KeyGen()
```

To retrieve the encoded private key

```go
privateKey := server.PrivateKey()
```

To retrieve the encoded public key

```go
privateKey := server.PublicKey()
```

### Server

You can instantiate a server with or without a private key, in which cas a new keypair is automatically created.

```go
server := voprf.Ristretto255.Server(nil)
```

or

```go
server := voprf.Ristretto255.Server(privateKeyBytes)
```

A verifiable server will add NIZK proofs in the evaluation of client requests.
If the client wants to verify the server's output, it will need the server's public key ideally provided out of band.

Instantiating a verifiable server is just as straightforward
```go
vServer := voprf.Ristretto255.VerifiableServer(privateKeyBytes)
```

### Client

The client can be instantiated in one of 4 ways using the  `Client()` and `ClientAdditive()` functions, depending on the setup

|   | Multiplicative | Additive |
|:-------------:|:-------------:|:-------------:|
| Base | Client(nil) | ClientAdditive(nil, ppb) |
| Verifiable | Client(pk)| ClientAdditive(pk, ppb)|

where ```pk``` is the server's public key, and ```ppb``` the *pre-processed blind*.

#### When and why use the multiplicative or additive blinding ?

Additive blinding is an optimisation over the multiplicative one in offline pre-processing values that will be used when blinding.
This can be of advantage if the client has the ability (i.e. long-term memory) to securely retain these sensitive values. 

#### Preprocessing values for additive blinding

The client executes this once, when set up before protocol execution
```go
import "github.com/bytemare/cryptotools/encoding"

enc := encoding.JSON

// The client preprocesses some values given the server's public key,
// and should store it and retrieve it when needed.
preprocessed := RistrettoSha512.Preprocess(serverPubKey)

// Encode the preprocessed values for storage, and store it.
encodedPPB, err := preprocessed.Encode(enc)
if err != nil {
	panic(err)
}
```

When instantiating a new client, the pre-processed values should be decoded and given to the client
```go
import "github.com/bytemare/cryptotools/encoding"

enc := encoding.JSON

// Upon retrieval, decode/restore it.
decodedPPB, err := DecodePreprocessedBlind(encodedPPB, enc)
if err != nil {
	panic(err)
}

// Instantiate a new client with the preprocessed values
client := RistrettoSha512.ClientAdditive(nil, decoded)
```

## Use case

The following projects use this OPRF implementation

* [OPAQUE](https://github.com/bytemare/opaque)
* [strong-AuCPace](https://github.com/bytemare/aucpace)

OPRF are generally used in protocols like
* password-authenticated key exchanges (PAKE)
* password-protected secret sharing schemes
* privacy-preserving password stores
* blind signatures

# Thanks and tributes

This package is just an implementation of the tremendous work and talent invested by researches and enthusiasts that care about your privacy and security.
All merit goes to the (V)OPRF team.

## Contributing

Please read [CONTRIBUTING.md](.github/CONTRIBUTING.md) for details on the code of conduct, and the process for submitting pull requests.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.